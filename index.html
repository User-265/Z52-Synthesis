<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>合成Z52</title>
    <link rel="icon" href="./avatar/52.jpg">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .tile-1 { background-color: #faf8ef; color: #776e65; }
            .tile-2 { background-color: #eee4da; color: #776e65; }
            .tile-4 { background-color: #ede0c8; color: #776e65; }
            .tile-8 { background-color: #f2b179; color: #f9f6f2; }
            .tile-9 { background-color: #f5a966; color: #f9f6f2; }
            .tile-11 { background-color: #f79e52; color: #f9f6f2; }
            .tile-16 { background-color: #f59563; color: #f9f6f2; }
            .tile-18 { background-color: #f68c50; color: #f9f6f2; }
            .tile-19 { background-color: #f8823d; color: #f9f6f2; }
            .tile-20 { background-color: #f9782a; color: #f9f6f2; }
            .tile-21 { background-color: #fa6e17; color: #f9f6f2; }
            .tile-23 { background-color: #fb6404; color: #f9f6f2; }
            .tile-24 { background-color: #e05a04; color: #f9f6f2; }
            .tile-25 { background-color: #c45003; color: #f9f6f2; }
            .tile-26 { background-color: #a94603; color: #f9f6f2; }
            .tile-28 { background-color: #8e3c02; color: #f9f6f2; }
            .tile-35 { background-color: #edcf72; color: #f9f6f2; }
            .tile-36 { background-color: #eec95f; color: #f9f6f2; }
            .tile-43 { background-color: #efc34c; color: #f9f6f2; }
            .tile-46 { background-color: #f0bd39; color: #f9f6f2; }
            .tile-47 { background-color: #f1b726; color: #f9f6f2; }
            .tile-52 { background-color: #f2b113; color: #f9f6f2; }
            .tile-special { animation: pulse 0.5s infinite; }
            .tile-flash { animation: flash-border 1s infinite; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes flash-border {
            0%, 100% { box-shadow: 0 0 0 4px rgba(246, 94, 59, 0.8); }
            50% { box-shadow: 0 0 0 4px rgba(246, 94, 59, 0.3); }
        }

        .tile {
            transition: transform 0.2s ease, opacity 0.2s ease, background-color 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tile.new-tile {
            animation: appear 0.3s ease-out;
        }

        .tile.merged-tile {
            animation: merge 0.3s ease-out;
            z-index: 20;
        }

        .tile.special-tile {
            animation: special 0.5s ease-out;
        }

        @keyframes appear {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes special {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        .tile-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }
    </style>
    <style>
        /* 自定义颜色配置 */
        :root {
            --color-primary: #faf8ef;       /* 米黄色背景 */
            --color-secondary: #bbada0;     /* 浅棕色容器 */
            --color-tertiary: #8f7a66;      /* 深棕色按钮 */
            --color-special: #edc53f;       /* 特殊按钮/元素 */
            --color-text: #776e65;          /* 文本颜色 */
            --color-empty: #cdc1b4;         /* 空白格子 */
        }

        body {
            background-color: var(--color-primary);
            color: var(--color-text);
        }

        .bg-primary { background-color: var(--color-primary); }
        .bg-secondary { background-color: var(--color-secondary); }
        .bg-tertiary { background-color: var(--color-tertiary); }
        .bg-special { background-color: var(--color-special); }
        .bg-empty { background-color: var(--color-empty); }
        .text-text { color: var(--color-text); }
        .text-white { color: white; }

        /* 按钮悬停效果 */
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="font-inter min-h-screen flex flex-col items-center justify-center p-4">
    <!--Github页角-->
    <a href="https://github.com/User-265/Z52-Synthesis" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <div class="max-w-md w-full">
        <header class="flex flex-col md:flex-row justify-between items-center mb-6">
            <div>
                <h1 class="text-[clamp(2.5rem,5vw,4rem)] font-bold text-text mb-2">合成Z52</h1>
                <p class="text-text/80 text-sm md:text-base">两只Z驱相加，可以得到第三只！</p>
            </div>
            <div class="flex flex-wrap gap-3 mt-4 md:mt-0">
                <div class="bg-secondary rounded-lg p-2 text-center">
                    <div class="text-xs uppercase text-primary/80">得分</div>
                    <div class="text-xl font-bold text-white" id="score">0</div>
                </div>
                <div class="bg-secondary rounded-lg p-2 text-center">
                    <div class="text-xs uppercase text-primary/80">最高得分</div>
                    <div class="text-xl font-bold text-white" id="best-score">0</div>
                </div>
                <div class="bg-special rounded-lg p-2 text-center">
                    <div class="text-xs uppercase text-primary/80">你合成了几只Z52?</div>
                    <div class="text-xl font-bold text-white" id="special-count">0</div>
                </div>
            </div>
        </header>


            <div id="game-area2" class="flex flex-wrap gap-3 mb-6">
                <button id="new-game" class="bg-tertiary hover:bg-tertiary/90 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200 shadow-md">
                    <i class="fa-solid fa-plus mr-2"></i>新的一局
                </button>
                <button id="toggle-display" class="bg-tertiary hover:bg-tertiary/90 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200 shadow-md">
                    <i class="fa-solid fa-image mr-2"></i><span id="toggle-text">显示数字</span>
                </button>
            </div>

            
            <div id="game-area" class="relative bg-secondary rounded-lg p-2 mb-6 shadow-lg">
                <div id="grid-container" class="grid grid-cols-4 gap-2">
                    <!-- Tiles will be generated here -->
                </div>
                <div id="game-message" class="hidden absolute inset-0 bg-black/70 rounded-lg flex flex-col items-center justify-center">
                    <p id="game-message-text" class="text-2xl font-bold text-white mb-4"></p>
                    <button id="game-message-button" class="bg-white hover:bg-gray-200 text-tertiary font-bold py-2 px-4 rounded-lg transition-all duration-200">
                        再来一次
                    </button>
                </div>
            </div>



        <footer class="text-center text-text/60 text-xs">
            <p>Created with <i class="fa-solid fa-heart text-red-500"></i> | Inspired by 2048 by Gabriele Cirulli</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game variables
            const gridSize = 4;
            let grid = [];
            let score = 0;
            let bestScore = localStorage.getItem('2048-best-score') || 0;
            let specialCount = localStorage.getItem('2048-special-count') || 0;
            let gameOver = false;
            let canMove = true;
            let lastPositions = [];
            let mergedPositions = [];
            let removedPositions = [];
            let tilesToRemove = [];
            let showImages = true; // 默认显示头像

            // 切换按钮事件
            const toggleButton = document.getElementById('toggle-display');
            const toggleText = document.getElementById('toggle-text');
            toggleButton.addEventListener('click', () => {
                showImages = !showImages;
                if (showImages) {
                    toggleText.textContent = '显示数字';
                } else {
                    toggleText.textContent = '显示头像';
                }
                renderGrid();
            });

            // 其他代码保持不变...
            const allowedNumbers = [1, 2, 4, 8, 9, 11, 16, 18, 19, 20, 21, 23, 24, 25, 26, 28, 35, 36, 43, 46, 47, 52];
            const specialNumbers = [46, 47, 52];
            const mergeRules = {
                2: [[1, 1]],
                4: [[2, 2]],
                8: [[4, 4]],
                16: [[8, 8]],
                9: [[1, 8]],
                11: [[2, 9]],
                18: [[2, 16], [9, 9]],
                19: [[1, 18]],
                20: [[1, 19], [2, 18], [9, 11]],
                21: [[1, 20], [2, 19]],
                23: [[2, 21], [4, 19]],
                24: [[1, 23], [4, 20], [8, 16]],
                25: [[2, 23], [9, 16]],
                26: [[1, 25], [8, 18]],
                28: [[2, 26], [4, 24], [8, 20], [9, 19]],
                35: [[9, 26], [11, 24], [16, 19]],
                36: [[1, 35], [8, 28], [11, 25], [16, 20], [18, 18]],
                43: [[8, 35], [18, 25], [19, 24], [20, 23]],
                46: [[11, 35], [18, 28], [23, 23]],
                47: [[1, 46], [4, 43], [11, 36]],
                52: [[9, 43], [16, 36], [26, 26]],
            };

            const gridContainer = document.getElementById('grid-container');
            const scoreElement = document.getElementById('score');
            const bestScoreElement = document.getElementById('best-score');
            const specialCountElement = document.getElementById('special-count');
            const newGameButton = document.getElementById('new-game');
            const gameMessage = document.getElementById('game-message');
            const gameMessageText = document.getElementById('game-message-text');
            const gameMessageButton = document.getElementById('game-message-button');

            bestScoreElement.textContent = bestScore;
            specialCountElement.textContent = specialCount;

            function initGame() {
                grid = createEmptyGrid();
                score = 0;
                gameOver = false;
                canMove = true;
                lastPositions = [];
                mergedPositions = [];
                removedPositions = [];
                tilesToRemove = [];
                scoreElement.textContent = score;
                gameMessage.classList.add('hidden');
                addRandomTile();
                addRandomTile();
                renderGrid();
            }

            function createEmptyGrid() {
                const grid = [];
                for (let i = 0; i < gridSize; i++) {
                    grid[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        grid[i][j] = 0;
                    }
                }
                return grid;
            }

            function addRandomTile() {
                if (!hasEmptyCell()) return false;
                let emptyCells = [];
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (grid[i][j] === 0) {
                            emptyCells.push({ x: i, y: j });
                        }
                    }
                }
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const rand = Math.random();
                const value = rand < 0.8 ? 1 : (rand < 0.95 ? 2 : 4);
                grid[randomCell.x][randomCell.y] = value;
                return true;
            }

            function hasEmptyCell() {
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (grid[i][j] === 0) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function getMergeResult(num1, num2) {
                for (const [result, pairs] of Object.entries(mergeRules)) {
                    const resultNum = parseInt(result);
                    for (const [a, b] of pairs) {
                        if ((num1 === a && num2 === b) || (num1 === b && num2 === a)) {
                            if (allowedNumbers.includes(resultNum)) {
                                return resultNum;
                            }
                        }
                    }
                }
                return null;
            }

            function isSpecialNumber(number) {
                return specialNumbers.includes(number);
            }

            function handleSpecialMerge(number, x, y) {
                if (isSpecialNumber(number)) {
                    let points = 0;
                    if (number === 46) points = 460;
                    else if (number === 47) points = 470;
                    else if (number === 52) points = 520;
                    score += points;
                    tilesToRemove.push({ x, y, number, timeoutId: null });
                    if (number === 52) {
                        specialCount++;
                        specialCountElement.textContent = specialCount;
                        localStorage.setItem('2048-special-count', specialCount);
                    }
                    return true;
                }
                return false;
            }

            function processTilesToRemove() {
                tilesToRemove.forEach(tile => {
                    removedPositions.push({ x: tile.x, y: tile.y, number: tile.number });
                    grid[tile.x][tile.y] = 0;
                });
                tilesToRemove = [];
                renderGrid();
            }

            function renderGrid() {
                gridContainer.innerHTML = '';
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile aspect-square rounded-lg flex items-center justify-center transition-all duration-200 ease-out';

                        const isNewTile = lastPositions.some(pos => pos.fromX === i && pos.fromY === j) || 
                                          mergedPositions.some(pos => pos.x === i && pos.y === j);
                                          
                        const isMergedTile = mergedPositions.some(pos => pos.x === i && pos.y === j);
                        const isRemovedTile = removedPositions.some(pos => pos.x === i && pos.y === j);
                        const isSpecialTile = tilesToRemove.some(t => t.x === i && t.y === j);

                        if (isNewTile) tile.classList.add('new-tile');
                        if (isMergedTile) tile.classList.add('merged-tile');
                        if (isRemovedTile) tile.classList.add('special-tile');
                        if (isSpecialTile) tile.classList.add('tile-flash');

                        if (grid[i][j] === 0) {
                            tile.classList.add('bg-empty');
                        } else {
                            const value = grid[i][j];
                            const tileClass = `tile-${value}`;
                            tile.classList.add(tileClass);

                            if (showImages) {
                                const img = document.createElement('img');
                                img.src = `avatar/${value}.jpg`;
                                img.className = 'tile-image';
                                img.alt = value;
                                img.onerror = function() {
                                    this.style.display = 'none';
                                    if (tile.querySelector('.tile-text')) {
                                        tile.querySelector('.tile-text').style.display = 'block';
                                    } else {
                                        const text = document.createElement('div');
                                        text.className = 'tile-text text-[clamp(1.2rem,5vw,2rem)] font-bold';
                                        text.textContent = value;
                                        tile.appendChild(text);
                                    }
                                };
                                tile.appendChild(img);
                                const text = document.createElement('div');
                                text.className = 'tile-text text-[clamp(1.2rem,5vw,2rem)] font-bold hidden';
                                text.textContent = value;
                                tile.appendChild(text);
                            } else {
                                const text = document.createElement('div');
                                text.className = 'tile-text text-[clamp(1.2rem,5vw,2rem)] font-bold';
                                text.textContent = value;
                                tile.appendChild(text);
                            }
                        }

                        const lastPos = lastPositions.find(pos => pos.toX === i && pos.toY === j);
                        if (lastPos) {
                            const dx = (lastPos.fromX - i) * 100;
                            const dy = (lastPos.fromY - j) * 100;
                            tile.style.transform = `translate(${dy}%, ${dx}%)`;
                            setTimeout(() => {
                                tile.style.transform = '';
                            }, 10);
                        }

                        gridContainer.appendChild(tile);
                    }
                }
                if (tilesToRemove.length > 0) {
                    setTimeout(processTilesToRemove, 1000);
                }
                lastPositions = [];
                mergedPositions = [];
                removedPositions = [];
            }

            // 移动逻辑保持不变...
            function moveUp() {
                let moved = false;
                lastPositions = [];
                mergedPositions = [];
                removedPositions = [];
                tilesToRemove = [];
                for (let j = 0; j < gridSize; j++) {
                    for (let i = 1; i < gridSize; i++) {
                        if (grid[i][j] !== 0) {
                            let newI = i;
                            const fromI = i;
                            const fromJ = j;
                            while (newI > 0 && grid[newI - 1][j] === 0) {
                                grid[newI - 1][j] = grid[newI][j];
                                grid[newI][j] = 0;
                                newI--;
                                moved = true;
                            }
                            if (newI > 0) {
                                const currentValue = grid[newI][j];
                                const aboveValue = grid[newI - 1][j];
                                const mergeResult = getMergeResult(currentValue, aboveValue);
                                if (mergeResult !== null) {
                                    const isSpecial = handleSpecialMerge(mergeResult, newI - 1, j);
                                    if (!isSpecial) {
                                        grid[newI - 1][j] = mergeResult;
                                        score += mergeResult;
                                        mergedPositions.push({ x: newI - 1, y: j });
                                    } else {
                                        grid[newI - 1][j] = mergeResult;
                                        mergedPositions.push({ x: newI - 1, y: j });
                                    }
                                    grid[newI][j] = 0;
                                    moved = true;
                                }
                            }
                            if (fromI !== newI) {
                                lastPositions.push({
                                    fromX: fromI,
                                    fromY: fromJ,
                                    toX: newI,
                                    toY: j
                                });
                            }
                        }
                    }
                }
                return moved;
            }

            function moveDown() {
                let moved = false;
                lastPositions = [];
                mergedPositions = [];
                removedPositions = [];
                tilesToRemove = [];
                for (let j = 0; j < gridSize; j++) {
                    for (let i = gridSize - 2; i >= 0; i--) {
                        if (grid[i][j] !== 0) {
                            let newI = i;
                            const fromI = i;
                            const fromJ = j;
                            while (newI < gridSize - 1 && grid[newI + 1][j] === 0) {
                                grid[newI + 1][j] = grid[newI][j];
                                grid[newI][j] = 0;
                                newI++;
                                moved = true;
                            }
                            if (newI < gridSize - 1) {
                                const currentValue = grid[newI][j];
                                const belowValue = grid[newI + 1][j];
                                const mergeResult = getMergeResult(currentValue, belowValue);
                                if (mergeResult !== null) {
                                    const isSpecial = handleSpecialMerge(mergeResult, newI + 1, j);
                                    if (!isSpecial) {
                                        grid[newI + 1][j] = mergeResult;
                                        score += mergeResult;
                                        mergedPositions.push({ x: newI + 1, y: j });
                                    } else {
                                        grid[newI + 1][j] = mergeResult;
                                        mergedPositions.push({ x: newI + 1, y: j });
                                    }
                                    grid[newI][j] = 0;
                                    moved = true;
                                }
                            }
                            if (fromI !== newI) {
                                lastPositions.push({
                                    fromX: fromI,
                                    fromY: fromJ,
                                    toX: newI,
                                    toY: j
                                });
                            }
                        }
                    }
                }
                return moved;
            }

            function moveLeft() {
                let moved = false;
                lastPositions = [];
                mergedPositions = [];
                removedPositions = [];
                tilesToRemove = [];
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 1; j < gridSize; j++) {
                        if (grid[i][j] !== 0) {
                            let newJ = j;
                            const fromI = i;
                            const fromJ = j;
                            while (newJ > 0 && grid[i][newJ - 1] === 0) {
                                grid[i][newJ - 1] = grid[i][newJ];
                                grid[i][newJ] = 0;
                                newJ--;
                                moved = true;
                            }
                            if (newJ > 0) {
                                const currentValue = grid[i][newJ];
                                const leftValue = grid[i][newJ - 1];
                                const mergeResult = getMergeResult(currentValue, leftValue);
                                if (mergeResult !== null) {
                                    const isSpecial = handleSpecialMerge(mergeResult, i, newJ - 1);
                                    if (!isSpecial) {
                                        grid[i][newJ - 1] = mergeResult;
                                        score += mergeResult;
                                        mergedPositions.push({ x: i, y: newJ - 1 });
                                    } else {
                                        grid[i][newJ - 1] = mergeResult;
                                        mergedPositions.push({ x: i, y: newJ - 1 });
                                    }
                                    grid[i][newJ] = 0;
                                    moved = true;
                                }
                            }
                            if (fromJ !== newJ) {
                                lastPositions.push({
                                    fromX: fromI,
                                    fromY: fromJ,
                                    toX: i,
                                    toY: newJ
                                });
                            }
                        }
                    }
                }
                return moved;
            }

            function moveRight() {
                let moved = false;
                lastPositions = [];
                mergedPositions = [];
                removedPositions = [];
                tilesToRemove = [];
                for (let i = 0; i < gridSize; i++) {
                    for (let j = gridSize - 2; j >= 0; j--) {
                        if (grid[i][j] !== 0) {
                            let newJ = j;
                            const fromI = i;
                            const fromJ = j;
                            while (newJ < gridSize - 1 && grid[i][newJ + 1] === 0) {
                                grid[i][newJ + 1] = grid[i][newJ];
                                grid[i][newJ] = 0;
                                newJ++;
                                moved = true;
                            }
                            if (newJ < gridSize - 1) {
                                const currentValue = grid[i][newJ];
                                const rightValue = grid[i][newJ + 1];
                                const mergeResult = getMergeResult(currentValue, rightValue);
                                if (mergeResult !== null) {
                                    const isSpecial = handleSpecialMerge(mergeResult, i, newJ + 1);
                                    if (!isSpecial) {
                                        grid[i][newJ + 1] = mergeResult;
                                        score += mergeResult;
                                        mergedPositions.push({ x: i, y: newJ + 1 });
                                    } else {
                                        grid[i][newJ + 1] = mergeResult;
                                        mergedPositions.push({ x: i, y: newJ + 1 });
                                    }
                                    grid[i][newJ] = 0;
                                    moved = true;
                                }
                            }
                            if (fromJ !== newJ) {
                                lastPositions.push({
                                    fromX: fromI,
                                    fromY: fromJ,
                                    toX: i,
                                    toY: newJ
                                });
                            }
                        }
                    }
                }
                return moved;
            }

            function checkLose() {
                if (hasEmptyCell()) return false;
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize - 1; j++) {
                        if (getMergeResult(grid[i][j], grid[i][j + 1]) !== null) {
                            return false;
                        }
                    }
                }
                for (let j = 0; j < gridSize; j++) {
                    for (let i = 0; i < gridSize - 1; i++) {
                        if (getMergeResult(grid[i][j], grid[i + 1][j]) !== null) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function handleGameState() {
                scoreElement.textContent = score;
                if (score > bestScore) {
                    bestScore = score;
                    bestScoreElement.textContent = bestScore;
                    localStorage.setItem('2048-best-score', bestScore);
                }
                }
                if (checkLose()) {
                    gameOver = true;
                    gameMessageText.textContent = '没有船坞了!';
                    gameMessage.classList.remove('hidden');
                    return;
                }
            }

            function handleKeydown(e) {
                if (!canMove || gameOver) return;
                let moved = false;
                switch (e.key) {
                    case 'ArrowUp':
                        moved = moveUp();
                        break;
                    case 'ArrowDown':
                        moved = moveDown();
                        break;
                    case 'ArrowLeft':
                        moved = moveLeft();
                        break;
                    case 'ArrowRight':
                        moved = moveRight();
                        break;
                    default:
                        return;
                }
                if (moved) {
                    canMove = false;
                    renderGrid();
                    const delay = tilesToRemove.length > 0 ? 1200 : 200;
                    setTimeout(() => {
                        addRandomTile();
                        renderGrid();
                        handleGameState();
                        canMove = true;
                    }, delay);
                }
            }

            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            function handleTouchStart(e) {
                if (!canMove || gameOver) return;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }

            function handleTouchEnd(e) {
                if (!canMove || gameOver) return;
                touchEndX = e.changedTouches[0].clientX;
                touchEndY = e.changedTouches[0].clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 20) {
                        moveRight();
                    } else if (diffX < -20) {
                        moveLeft();
                    }
                } else {
                    if (diffY > 20) {
                        moveDown();
                    } else if (diffY < -20) {
                        moveUp();
                    }
                }
                const moved = diffX > 20 || diffX < -20 || diffY > 20 || diffY < -20;
                if (moved) {
                    canMove = false;
                    renderGrid();
                    const delay = tilesToRemove.length > 0 ? 1200 : 200;
                    setTimeout(() => {
                        addRandomTile();
                        renderGrid();
                        handleGameState();
                        canMove = true;
                    }, delay);
                }
            }

            // 新增代码：阻止默认滚动行为
            const gameArea = document.getElementById('game-area');
            const gameArea2 = document.getElementById('game-area2');
            let isMouseInGameArea = false;

            gameArea.addEventListener('mouseenter', () => {
                isMouseInGameArea = true;
            });

            gameArea2.addEventListener('mouseenter', () => {
                isMouseInGameArea = true;
            });

            gameArea.addEventListener('mouseleave', () => {
                isMouseInGameArea = false;
            });

            gameArea2.addEventListener('mouseleave', () => {
                isMouseInGameArea = false;
            });

            document.addEventListener('keydown', (e) => {
                if (isMouseInGameArea && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                    e.preventDefault();
                    handleKeydown(e);
                }
            });

            gameArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleTouchStart(e);
            });

            gameArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleTouchEnd(e);
            });

            document.addEventListener('keydown', handleKeydown);
            document.addEventListener('touchstart', handleTouchStart);
            document.addEventListener('touchend', handleTouchEnd);
            newGameButton.addEventListener('click', initGame);
            gameMessageButton.addEventListener('click', initGame);
            initGame();
        });
    </script>
</body>
</html>
